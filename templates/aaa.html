<!DOCTYPE HTML>

<html>
<head>
	<title>OOP</title>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
	<link rel="stylesheet" href="assets/css/main.css" />
	<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
</head>
<body class="is-preload">
<div id="page-wrapper">

	<!-- Header -->
	<header id="header">
		<h1 id="logo"><a href="index.html">Project-3</a></h1>
		<nav id="nav">
			<ul>
				<li><a href="index.html">Home</a></li>
				<li><a href="calculator.html">CALCULATOR</a></li>
				<li><a href="oop.html">OBJECT ORIENTED PROGRAMMING</a></li>
				<li><a href="aaa.html">AAA TESTING</a></li>
				<li><a href="oopincal.html">OOP IN CALCULATOR</a></li>
				<li><a href="pylint.html">PYLINT</a></li>
				<li><a href="seperation.html">SEPERATION OF CONCERNS</a></li>
				<a href="index..html"><b>PROJECT1</b></a>
			</ul>
		</nav>
	</header>

	<!-- Main -->
	<div id="main" class="wrapper style1">
		<div class="container">
			<header class="major">
				<h2>AAA TESTING</h2>
				<p>AAA(Arrange, Act, Assert)</p>
			</header>

			<!-- Content -->
			<section id="content">
				<img src="images/i7.png"  height="500" width="1100"  class="align-center"  /></a>
				<h2>What Is AAA TESTING?</h2>
				<p>The AAA pattern is a common unit testing pattern. It is a way to arrange and organize
					test code to make unit tests clear and understandable, and consists of separating
					each unit test method into three sections: Arrange, Act, and Assert. A test is a
					procedure that exercises a behavior to determine if the behavior functions correctly.
					There are several different kinds of tests, like unit tests, integration tests, or
					end-to-end tests, but all functional tests do the same basic thing: they try something
					and report PASS or FAIL.

					<br><h2>What is Arrange, Act and Assert</h2> </p>

				<h2>ARRANGE</h2>
				<ul>
					<li>ARRANGE section you only have code required to setup that specific test.
						Here objects would be created, mocks setup (if you are using one) and potentially
						expectations would be set. Arrange inputs and targets. Arrange steps should set
						up the test case. Does the test require any objects or special settings?
						Does it need to prep a database? Does it need to log into a web app? Handle all
						of these operations at the start of the test.</li>
				</ul>

				<h2>ACT</h2>
				<ul>
					<li>ACT section which should be the invocation of the method being tested.
						Act on the target behavior. Act steps should cover the main thing to be tested.
						This could be calling a function or method, calling a REST API, or interacting with a web page.
						Keep actions focused on the target behavior.</li>
				</ul>

				<h2>ASSERT</h2>
				<ul>
					<li>ASSERT section would simply check whether the expectations were met.
						Assert expected outcomes. Act steps should elicit some sort of response.
						Assert steps verify the goodness or badness of that response. Sometimes,
						assertions are as simple as checking numeric or string values. Other times,
						they may require checking multiple facets of a system. Assertions will ultimately
						determine if the test passes or fails.</li>
				</ul>

				<h2>UNIT TESTING</h2>
				<ul>
					<li>Unit testing is a method that is used to test programs and applications to see
						if they function according to the clientsâ€™ specifications. Unit testing involves
						testing individual components of the software program or application. The main purpose
						behind this is to check that all the individual parts are working as intended.
						A unit is known as the smallest possible component of software that can be tested.
						Generally, it has a few inputs and a single output.</li>

					<li>There are two main types of unit testing: manual and automated. The automated
						method is the most preferred as it is faster and more accurate, but performing
						this task manually is also an option. The manual approach has a step-by-step
						instructional procedure that helps testers perform this task efficiently.
						The automated unit testing usually involves the developer first writing a section of
						the code in the application so that the function can be tested.</li>
				</ul>

				<h2>Unit Testing Process</h2>
				<h3>The workflow of unit testing in software testing usually follows this framework:</h3>
				<ul>
					<li> Create the test cases</li>
					<li> Review or rework </li>
					<li> Baseline </li>
					<li> Execute test cases</li>
				</ul>

				<h2>Advantages of Unit Testing:</h2>
				<ul>
				<li>The process becomes agile</li>
				<li>Quality of Code </li>
				<li>Facilitates Change</li>
				<li>Provides Documentation </li>
				<li>Debugging Process </li>
				<li>Design</li>
				<li>Reduce Costs</li>
				</ul>

				<h2>Importance Of Unit Testing </h2>
				<ul>
				<li>Automated unit tests reduce the number of bugs released in the production.
					The best unit testing will come from a developer very close to the project and writing
					unit tests helps some developers to understand the code better. It can often be a good
					way for new developers on the project to get to know code if it was written by someone else.
					For the best practice, all projects must be under unit testing, but normally it is used for
					larger projects. Smaller projects can still benefit from unit tests, but project managers and
					clients should evaluate the time needed to develop unit tests during the project.</li>
				</ul>

				<h2>WHY THIS TESTING IS IMPORTANT</h2>
				<ul>
				<li>Readability is a major advantage to arrange, act, assert tests. Tests often do double duty.
					They verify behavior and act as documentation. So the easier it is to open up a test class
					and decipher what it's doing, the better.</li>
				<li>We have four test methods instead of one. If one of them fails,
					we'll immediately know what went wrong. Unlike the first example,
					each method has only one reason to change and one reason to fail.
					In a large and complicated code base, tests that honor the single
					responsibility principle are much easier to troubleshoot.</li>
				<li>The testing is important since it discovers defects/bugs before the delivery to the client,
					which guarantees the quality of the software.
					It makes the software more reliable and easy to use.</li>
				<li>Software testing is a method of determining whether the actual software product meets the
					expected requirements and ensuring that the software product is free of defects.
					It entails running software/system components through their paces using manual
					or automated tools to evaluate one or more properties of interest.</li>
				<li>The goal of software testing is to find errors, gaps, or missing requirements in comparison
					to the actual requirements.</li>
				</ul>

				<h2>IN CALCULATOR</h2>
				<p class="grw-font"><h3>Python Reference file: calculator_test.py</p></h3>
				<ul style="list-style-type:none;">
					<li>def <b>test_add_numbers(clear_history_fixture)</b>:</li>
					<li>&nbsp;&nbsp;&nbsp;&nbsp;"""test addition of numbers"""</li>
					<li>&nbsp;&nbsp;&nbsp;&nbsp;# pylint: disable=unused-argument,redefined-outer-name
					</li>
					<li>&nbsp;&nbsp;&nbsp;&nbsp;# <b>Arrange</b></li>
					<li>&nbsp;&nbsp;&nbsp;&nbsp;numbers = (2.0, 3.0, 4.0)</li>
					<li>&nbsp;&nbsp;&nbsp;&nbsp;# <b>Act</b></li>
					<li>&nbsp;&nbsp;&nbsp;&nbsp;Calculator.add_numbers(numbers)</li>
					<li>&nbsp;&nbsp;&nbsp;&nbsp;# <b>Assert</b></li>
					<li>&nbsp;&nbsp;&nbsp;&nbsp;assert <b>Calculations.get_first_calculation_object().get_output()
						== 9.0</b></li>
					<li>&nbsp;&nbsp;&nbsp;&nbsp;assert
						isinstance(Calculations.get_last_calculation_object(), Addition)
					</li></ul>
				<br>
				<ul style="list-style-type:none;">
					<li>calculator_test.py method test_add_numbers tests add_numbers method of the
						Calculator (calculator.py)
						in arrange - we initialize the tuple to be ued for testing.
						in act - we invoke method to be tested i.e, add_numbers and pass the tuple to
						it.
						in assert - we check the behaviour if the condition of the test met or not met
						to define the success of the test case

					</li>
				</ul>

				<h2>EXCEPTION TEST CASE IN CALCULATOR</h2>
				<ul style="list-style-type:none;">
					<li>def test_divide_numbers(clear_history_fixture):</li>
					<li>&nbsp;&nbsp;&nbsp;&nbsp;"""test division of numbers"""</li>
					<li>&nbsp;&nbsp;&nbsp;&nbsp;# pylint: disable=unused-argument,redefined-outer-name
					</li>
					<li>&nbsp;&nbsp;&nbsp;&nbsp;<b># Arrange</b></li>
					<li>&nbsp;&nbsp;&nbsp;&nbsp;my_numbers = (3.0, 1.0, 1.0)</li>
					<li>&nbsp;&nbsp;&nbsp;&nbsp;<b># Act</b></li>
					<li>&nbsp;&nbsp;&nbsp;&nbsp;Calculator.divide_numbers(my_numbers)</li>
					<li>&nbsp;&nbsp;&nbsp;&nbsp;<b># Assert</b></li>
					<li>&nbsp;&nbsp;&nbsp;&nbsp;assert Calculations.get_first_calculation_result_value()
						== "0.33"
					</li>
					<li>&nbsp;&nbsp;&nbsp;&nbsp;<b>with pytest.raises(ZeroDivisionError):</b></li>
					<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;another_no = (1.0, 0.0) <b>#
						Arrange</b></li>
					<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calculator.divide_numbers(another_no)
						<b># Act</b></li>
					<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert
						Calculations.get_last_calculation_result_value() == 1.0 <b># Assert</b></li>
					<li>&nbsp;&nbsp;&nbsp;&nbsp;# Below statement is not part of any coverage</li>
					<li>&nbsp;&nbsp;&nbsp;&nbsp;assert
						isinstance(Calculations.get_last_calculation_object(), Division)
					</li>

				</ul>
				<h2>VALIDATING EXTERNAL DATA FOR TESTING CALCULATOR</h2>
				<ul>
					<li>In below example, there are three files in reference - readfile.py, readcsv.py
						and readcsv_test.py
					</li>
					<li>CSV file Addition.csv is placed under cal2../tests/testdata/Addition.csv
					</li>
					<li>Base class ReadFile initializes the protected member (_path) through
						parameterized constructor init
					</li>
					<li>Subclass ReadCSV extends the property and behaviour of the baseclass meaning the
						_path and init constructor as well.
					</li>
					<li>Subclass has instance method read_csv_file which reads the csv on provided
						location and assign to dataframe.
					</li>
					<li>test file uses the os package to play around with the path.The path is used as a
						fixture using @pytest.mark.datafiles.this we can pass to any method we want to
						have the file path or using @pytest.mark.datafiles we can define multiple files
						also.
					</li>
				</ul>

				<p class="grw-font"><h2>Example</h2></p>
				<ul style="list-style-type:none;">
					<li>"""Base class for reading file"""</li>
				<br><ul style="list-style-type:none;">
				<li><b>class ReadFile:</b></li>
				<li>&nbsp;&nbsp;&nbsp;&nbsp;"""Read file"""</li></ul>
				<ul style="list-style-type:none;">
					<li>&nbsp;&nbsp;&nbsp;&nbsp;# The __init__ method is a constructor and runs as soon
						as an
					</li>
					<li>&nbsp;&nbsp;&nbsp;&nbsp;# object of a Operation class is instantiated.</li>
					<li>&nbsp;&nbsp;&nbsp;&nbsp;# pylint: disable=too-few-public-methods</li>
					<li>&nbsp;&nbsp;&nbsp;&nbsp;def <b>__init__</b>(self, path: str):</li>
					<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"""Parameterized Constructor set
						the path"""
					</li>
					<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._path = path</li>
				<br><ul style="list-style-type:none;">
				<li>"""Subclass Class for Reading CSV"""</li>
				<li>import pandas as pd</li>

				<li>from calc.file_utils.readfile import ReadFile</li>


				<li><b>class ReadCSV(ReadFile):</b></li>
				<li>&nbsp;&nbsp;&nbsp;&nbsp;"""subclass extending ReadFile to read csv"""</li>

				<li>&nbsp;&nbsp;&nbsp;&nbsp;# pylint: disable=too-few-public-methods</li>
				<li>&nbsp;&nbsp;&nbsp;&nbsp;# This is the instance method</li>
				<li>&nbsp;&nbsp;&nbsp;&nbsp;def <b>read_csv_file(self):</b></li>
				<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"""reading csv file"""</li>
				<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data_frame =
					pd.read_csv(self._path)
				</li>
				<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print("data_frame : ",
					data_frame[:])
				</li>
				<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return True</li>
				<br><ul style="list-style-type:none;">
				<li><b>"""Testing of Read CSV"""</b></li>
				<li>import os</li>
				<li>import pytest</li></ul>
				<ul style="list-style-type:none;">
				<li>from calc.file_utils.readcsv import ReadCSV</li></ul>
				<ul style="list-style-type:none;">
				<li>FIXTURE_DIR = os.path.join(</li>
				<li>
					os.path.dirname(os.path.realpath('C://Users//yeswanth//PycharmProjects//calc2//')),
				</li>
				<li>'calc2//tests//test_data')</li>
				<li><b>@pytest.mark.datafiles(</b></li>
				<li><b>os.path.join(FIXTURE_DIR, 'addition.csv') )</b></li>
				<li>def <b>test_read_csv_file(datafiles):</b></li>
				<li>&nbsp;&nbsp;&nbsp;&nbsp;"""test read csv file"""</li>
				<li>&nbsp;&nbsp;&nbsp;&nbsp;assert ReadCSV(datafiles).read_csv_file() is True</li>
			</ul>

			</section>

		</div>
	</div>

	<!-- Footer -->
	<footer id="footer">
		<ul class="icons">
			<li><a href="#" class="icon brands alt fa-twitter"><span class="label">Twitter</span></a></li>
			<li><a href="#" class="icon brands alt fa-facebook-f"><span class="label">Facebook</span></a></li>
			<li><a href="#" class="icon brands alt fa-linkedin-in"><span class="label">LinkedIn</span></a></li>
			<li><a href="#" class="icon brands alt fa-instagram"><span class="label">Instagram</span></a></li>
			<li><a href="#" class="icon brands alt fa-github"><span class="label">GitHub</span></a></li>
			<li><a href="#" class="icon solid alt fa-envelope"><span class="label">Email</span></a></li>
		</ul>
		<ul class="copyright">
			<li>&copy; YESWANTH SAI</li><br>
			<br>
			<a href="w3c.html">W3C</a>
		</ul>
	</footer>

</div>

</div>

<!-- Scripts -->
<script src="assets/js/jquery.min.js"></script>
<script src="assets/js/jquery.scrolly.min.js"></script>
<script src="assets/js/jquery.dropotron.min.js"></script>
<script src="assets/js/jquery.scrollex.min.js"></script>
<script src="assets/js/browser.min.js"></script>
<script src="assets/js/breakpoints.min.js"></script>
<script src="assets/js/util.js"></script>
<script src="assets/js/main.js"></script>

</body>
</html>